<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Crown Mural - 436 Regions</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
    }
    
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Canvas-based approach for 436 regions */
    #mural-canvas {
      max-width: 100%;
      max-height: 100%;
      cursor: crosshair;
      image-rendering: pixelated;
    }
    
    #id-canvas {
      display: none; /* Hidden canvas for ID mapping */
    }
    
    /* Loading indicator */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: gold;
    }
    
    /* Tooltip styling */
    #tooltip {
      position: fixed;
      pointer-events: none;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 6px;
      padding: 12px 16px;
      font-size: 14px;
      transform: translate(8px, -8px);
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: none;
      z-index: 1000;
      max-width: 280px;
    }
    
    #tooltip strong {
      color: gold;
      display: block;
      margin-bottom: 4px;
      font-size: 15px;
    }
    
    #tooltip .blurb {
      color: #999;
      line-height: 1.4;
    }
    
    /* Stats display */
    #stats {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="loading">Loading 436 regions...</div>
    
    <!-- Main display canvas -->
    <canvas id="mural-canvas"></canvas>
    
    <!-- Hidden ID-map canvas for O(1) hit detection -->
    <canvas id="id-canvas"></canvas>
  </div>
  
  <div id="tooltip">
    <strong></strong>
    <div class="blurb"></div>
  </div>
  
  <div id="stats">
    <div>Regions: <span id="region-count">0</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>

  <script type="module">
    // Canvas-based mural controller for 436 regions
    class CrownMuralController {
      constructor() {
        this.canvas = document.getElementById('mural-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.idCanvas = document.getElementById('id-canvas');
        this.idCtx = this.idCanvas.getContext('2d', { willReadFrequently: true });
        
        this.tooltip = document.getElementById('tooltip');
        this.tooltipTitle = this.tooltip.querySelector('strong');
        this.tooltipBlurb = this.tooltip.querySelector('.blurb');
        this.loading = document.getElementById('loading');
        
        // Region data
        this.regions = new Map(); // id -> {mask, bbox, project}
        this.regionColors = new Map(); // id -> display color
        this.hoveredRegion = null;
        
        // Performance tracking
        this.lastFrameTime = 0;
        this.fps = 0;
        
        // Load configuration
        this.maskPath = './shape_masks/';
        this.baseImage = null;
        
        this.init();
      }
      
      async init() {
        try {
          // Load base image
          await this.loadBaseImage('./coloured_regions.png');
          
          // Load mask metadata
          await this.loadRegionData();
          
          // Build ID map for O(1) hit detection
          await this.buildIDMap();
          
          // Setup event handlers
          this.setupEventHandlers();
          
          // Hide loading
          this.loading.style.display = 'none';
          
          // Start render loop
          this.animate();
        } catch (err) {
          console.error('Failed to initialize:', err);
          this.loading.textContent = 'Failed to load regions';
        }
      }
      
      async loadBaseImage(path) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            this.baseImage = img;
            
            // Set canvas dimensions
            this.canvas.width = img.width;
            this.canvas.height = img.height;
            this.idCanvas.width = img.width;
            this.idCanvas.height = img.height;
            
            // Draw base image
            this.ctx.drawImage(img, 0, 0);
            resolve();
          };
          img.onerror = reject;
          img.src = path;
        });
      }
      
      async loadRegionData() {
        // Generate project data for 436 regions
        const projectTypes = [
          { prefix: 'neural-', titles: ['Network Analyzer', 'Pattern Matcher', 'Data Clusterer'] },
          { prefix: 'render-', titles: ['Path Tracer', 'Rasterizer', 'Ray Marcher'] },
          { prefix: 'compiler-', titles: ['Parser', 'Optimizer', 'Code Generator'] },
          { prefix: 'crypto-', titles: ['Hash Function', 'Key Generator', 'Cipher'] },
          { prefix: 'sim-', titles: ['Physics Engine', 'Particle System', 'Fluid Dynamics'] },
          { prefix: 'viz-', titles: ['Graph Layout', 'Data Plotter', 'Chart Renderer'] },
          { prefix: 'audio-', titles: ['Synthesizer', 'Sampler', 'Effects Processor'] },
          { prefix: 'game-', titles: ['Entity System', 'Collision Detector', 'AI Controller'] }
        ];
        
        // Load mask data for each region
        for (let i = 0; i < 436; i++) {
          const type = projectTypes[i % projectTypes.length];
          const titleIdx = Math.floor(i / projectTypes.length) % type.titles.length;
          
          this.regions.set(i, {
            id: i,
            maskPath: `${this.maskPath}shape_${String(i).padStart(3, '0')}.png`,
            project: {
              title: `${type.titles[titleIdx]} v${Math.floor(i/50) + 1}`,
              href: `/projects/${type.prefix}${i}`,
              blurb: `Region ${i}: Advanced ${type.titles[titleIdx].toLowerCase()} implementation`
            },
            color: this.getRegionColor(i)
          });
        }
        
        document.getElementById('region-count').textContent = this.regions.size;
      }
      
      getRegionColor(id) {
        // Generate distinct color for each region ID
        const hue = (id * 137.5) % 360; // Golden angle for distribution
        const sat = 50 + (id % 30);
        const light = 40 + (id % 20);
        return `hsl(${hue}, ${sat}%, ${light}%)`;
      }
      
      async buildIDMap() {
        // Create ID map where each pixel color encodes region ID
        // This enables O(1) hit detection
        
        this.idCtx.fillStyle = 'black';
        this.idCtx.fillRect(0, 0, this.idCanvas.width, this.idCanvas.height);
        
        // For actual implementation, you'd load each mask and draw with unique color
        // For now, simulate with random regions
        for (const [id, region] of this.regions) {
          // Convert ID to RGB color (supports up to 16.7M regions)
          const r = (id >> 16) & 0xFF;
          const g = (id >> 8) & 0xFF;
          const b = id & 0xFF;
          
          // In production, load actual mask and draw
          // For demo, create sample regions
          const x = (id % 20) * 100;
          const y = Math.floor(id / 20) * 50;
          
          this.idCtx.fillStyle = `rgb(${r},${g},${b})`;
          this.idCtx.fillRect(x, y, 90, 40);
        }
      }
      
      setupEventHandlers() {
        let rafId = 0;
        let lastX = -1, lastY = -1;
        
        this.canvas.addEventListener('pointermove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const x = Math.floor((e.clientX - rect.left) * (this.canvas.width / rect.width));
          const y = Math.floor((e.clientY - rect.top) * (this.canvas.height / rect.height));
          
          // Only process if position changed
          if (x !== lastX || y !== lastY) {
            lastX = x;
            lastY = y;
            
            if (!rafId) {
              rafId = requestAnimationFrame(() => {
                rafId = 0;
                this.handleHover(x, y, e.clientX, e.clientY);
              });
            }
          }
        });
        
        this.canvas.addEventListener('pointerleave', () => {
          this.clearHover();
        });
        
        this.canvas.addEventListener('click', (e) => {
          if (this.hoveredRegion) {
            const region = this.regions.get(this.hoveredRegion);
            if (region?.project) {
              console.log(`Navigate to: ${region.project.href}`);
              // location.href = region.project.href;
            }
          }
        });
      }
      
      handleHover(canvasX, canvasY, screenX, screenY) {
        // O(1) hit detection using ID map
        const pixel = this.idCtx.getImageData(canvasX, canvasY, 1, 1).data;
        const id = (pixel[0] << 16) | (pixel[1] << 8) | pixel[2];
        
        if (id === 0 || !this.regions.has(id)) {
          this.clearHover();
          return;
        }
        
        if (id !== this.hoveredRegion) {
          this.hoveredRegion = id;
          const region = this.regions.get(id);
          
          // Update tooltip
          if (region?.project) {
            this.tooltipTitle.textContent = region.project.title;
            this.tooltipBlurb.textContent = region.project.blurb;
            this.tooltip.style.display = 'block';
            this.tooltip.style.left = `${screenX}px`;
            this.tooltip.style.top = `${screenY}px`;
          }
          
          // Trigger redraw for highlight
          this.needsRedraw = true;
        }
      }
      
      clearHover() {
        if (this.hoveredRegion !== null) {
          this.hoveredRegion = null;
          this.tooltip.style.display = 'none';
          this.needsRedraw = true;
        }
      }
      
      render() {
        // Redraw base image
        if (this.baseImage) {
          this.ctx.drawImage(this.baseImage, 0, 0);
        }
        
        // Highlight hovered region
        if (this.hoveredRegion !== null) {
          const region = this.regions.get(this.hoveredRegion);
          if (region) {
            // Draw highlight overlay
            this.ctx.save();
            this.ctx.globalCompositeOperation = 'screen';
            this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            
            // In production, use actual mask
            // For demo, highlight sample area
            const x = (this.hoveredRegion % 20) * 100;
            const y = Math.floor(this.hoveredRegion / 20) * 50;
            this.ctx.fillRect(x, y, 90, 40);
            
            this.ctx.restore();
          }
        }
      }
      
      animate(timestamp = 0) {
        // Calculate FPS
        if (this.lastFrameTime) {
          const delta = timestamp - this.lastFrameTime;
          this.fps = Math.round(1000 / delta);
          document.getElementById('fps').textContent = this.fps;
        }
        this.lastFrameTime = timestamp;
        
        // Only render if needed
        if (this.needsRedraw) {
          this.render();
          this.needsRedraw = false;
        }
        
        requestAnimationFrame((t) => this.animate(t));
      }
    }
    
    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => new CrownMuralController());
    } else {
      new CrownMuralController();
    }
  </script>
</body>
</html>